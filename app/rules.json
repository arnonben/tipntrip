{
  "rules": {
     "users": {
          ".read": "auth != null",
          "$user": {
            ".write": "auth.uid === $user && (!newData.exists() || newData.hasChildren())",
            "first_name": {
               ".validate": "newData.isString() && newData.val().length <= 200"
            },
            "last_name": {
               ".validate": "newData.isString() && newData.val().length <= 200"
            },
            "username": {
               ".validate": "newData.isString() && newData.val().length <= 200"
            },
            "email": {
               ".validate": "newData.isString() && newData.val().length <=320"
            },
            "EnterToSend":{
               ".validate": "newData.val()==true || newData.val()==false"
            },
            "$other": {
               ".validate": false
            }
         }
    },
    "chat-messages": {
      ".read": "auth != null",
      ".write":  "auth != null",
      "$chatId": {
          ".indexOn": ["createdAt"] 
      }
    },
    "user-chats": {
      ".read": "auth != null",
      ".write": "auth != null",
      "$chatId": {
        ".indexOn": ["modifiedAt"]
      }
    },
    "chat-members": {
      ".read": "auth != null",
      ".write": "auth != null"
    },
    "chat-metas": {
      ".read":"auth != null",
      ".write":"auth != null"
    },
    "advisors": {
      ".read":"auth != null",
      ".write":"auth != null"
    },
    "advisors-destinations": {
      ".read":"auth != null",
      ".write":"auth != null"
    },
    "advisors-interests": {
      ".read":"auth != null",
      ".write":"auth != null"
    },
    "search": {
         "request": {
            "$recid": {
               // I can only read records assigned to me
               ".read": "auth.id === data.child('id').val() || auth.uid === data.child('id').val()",
               // I can only write new records that don't exist yet
               ".write": "!data.exists() && (newData.child('id').val() === auth.id || newData.child('id').val() === auth.uid)",
               ".validate": "newData.hasChildren(['query', 'index', 'type'])",
               "index": {
                  // accepts arrays or strings
                  ".validate": "(newData.isString() && newData.val().length < 1000) || newData.hasChildren()",
                  "$child": {
                     ".validate": "newData.isString() && newData.val().length < 1000"
                  }
               },
               "type": {
                  // accepts arrays or strings
                  ".validate": "(newData.isString() && newData.val().length < 1000) || newData.hasChildren()",
                  "$child": {
                     ".validate": "newData.isString() && newData.val().length < 1000"
                  }
               },
               "query": {
                  // structure of the query object is pretty open-ended
                  ".validate": "newData.isString() || newData.hasChildren()"
               },
               "$other": {
                  ".validate": false
               }
            }
         },
         "response": {
            "$recid": {
               // I can only read/write records assigned to me
               ".read": "auth.id === data.child('id').val() || auth.uid === data.child('id').val()",
               ".write": "auth.id === data.child('id').val() || auth.uid === data.child('id').val()",
               // Assumes that Flashlight will be writing the records using a secret or a token that has admin: true
               // The only thing a logged in user needs to do is delete results after reading them
               ".validate": false
            }
         }
      }
  }
}